<html>
<head>
<meta charset="UTF-8">
<title>Mini Among Us Firebase v10</title>
<style>
  body { 
    margin:0; 
    overflow:hidden; 
    background:#111; 
    font-family: Arial, sans-serif;
  }
  canvas { 
    background:#1e1e1e; 
    display:block; 
    margin:0 auto; 
  }
  #loginScreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  #loginBox {
    background: #2a2a2a;
    padding: 40px;
    border-radius: 15px;
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
    text-align: center;
  }
  #loginBox h1 {
    color: #00ffff;
    margin-bottom: 30px;
    font-size: 32px;
    text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
  }
  #loginBox input {
    width: 250px;
    padding: 12px;
    font-size: 16px;
    border: 2px solid #00ffff;
    border-radius: 8px;
    background: #1a1a1a;
    color: #fff;
    margin-bottom: 20px;
  }
  #loginBox input:focus {
    outline: none;
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
  }
  #loginBox button {
    width: 276px;
    padding: 12px;
    font-size: 18px;
    background: #00ffff;
    border: none;
    border-radius: 8px;
    color: #000;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
  }
  #loginBox button:hover {
    background: #00cccc;
    transform: scale(1.05);
  }
  #loginBox button:active {
    transform: scale(0.95);
  }
  .hidden {
    display: none !important;
  }
  #userInfo {
    position: fixed;
    top: 10px;
    left: 10px;
    color: #00ffff;
    font-size: 14px;
    background: rgba(0, 0, 0, 0.7);
    padding: 10px 15px;
    border-radius: 8px;
    z-index: 100;
  }
  #playerCount {
    position: fixed;
    top: 10px;
    right: 10px;
    color: #00ff00;
    font-size: 14px;
    background: rgba(0, 0, 0, 0.7);
    padding: 10px 15px;
    border-radius: 8px;
    z-index: 100;
    border: 2px solid #00ff00;
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
  }
  #killCounter {
    position: fixed;
    top: 55px;
    right: 10px;
    color: #ff6600;
    font-size: 14px;
    background: rgba(0, 0, 0, 0.7);
    padding: 10px 15px;
    border-radius: 8px;
    z-index: 100;
    border: 2px solid #ff6600;
    box-shadow: 0 0 10px rgba(255, 102, 0, 0.3);
  }
  #inventoryBar {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
    background: rgba(0, 0, 0, 0.8);
    padding: 15px;
    border-radius: 10px;
    border: 2px solid #00ffff;
    z-index: 100;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
  }
  .inventory-slot {
    width: 60px;
    height: 60px;
    background: rgba(50, 50, 50, 0.9);
    border: 2px solid #666;
    border-radius: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
    font-size: 12px;
    color: #fff;
    text-align: center;
    padding: 5px;
    box-sizing: border-box;
    position: relative;
    overflow: hidden;
  }
  .inventory-slot:hover {
    border-color: #00ffff;
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    transform: scale(1.05);
  }
  .inventory-slot.active {
    border-color: #00ff00;
    background: rgba(0, 255, 0, 0.2);
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.6);
    transform: scale(1.1);
  }
  .cooldown-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background: rgba(0, 0, 0, 0.6);
    height: 0%;
    transition: height 0.05s linear;
    pointer-events: none;
  }
  .cooldown-text {
    position: absolute;
    bottom: 2px;
    right: 2px;
    font-size: 10px;
    color: #fff;
    font-weight: bold;
    text-shadow: 0 0 2px #000;
    pointer-events: none;
  }
  #chatMessages {
    position: fixed;
    bottom: 100px;
    left: 10px;
    width: 250px;
    max-height: 200px;
    overflow: hidden;
    background: transparent;
    border: none;
    border-radius: 8px;
    padding: 10px;
    z-index: 100;
    color: #fff;
    font-size: 12px;
  }
  #chatMessages.chatOpen {
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid #00ffff;
  }
  #chatInput {
    position: fixed;
    bottom: 100px;
    left: 10px;
    width: 250px;
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #00ffff;
    border-radius: 8px;
    padding: 10px;
    z-index: 100;
    display: flex;
    gap: 5px;
  }
  #chatInput.hidden {
    display: none !important;
  }
  #chatInputField {
    flex: 1;
    padding: 8px;
    background: #1a1a1a;
    border: 1px solid #00ffff;
    border-radius: 5px;
    color: #fff;
    font-size: 12px;
  }
  #chatInputField:focus {
    outline: none;
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
  }
  #chatSendBtn {
    padding: 8px 12px;
    background: #00ffff;
    border: none;
    border-radius: 5px;
    color: #000;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s;
  }
  #chatSendBtn:hover {
    background: #00cccc;
    transform: scale(1.05);
  }
  #chatSendBtn:active {
    transform: scale(0.95);
  }
  .chatMsg {
    margin-bottom: 5px;
    word-wrap: break-word;
  }
  .chatMsg .username {
    color: #00ffff;
    font-weight: bold;
  }
  #healthBar {
    position: fixed;
    top: 60px;
    left: 10px;
    width: 150px;
    height: 20px;
    background: rgba(0, 0, 0, 0.8);
    border: 2px solid #00ff00;
    border-radius: 10px;
    padding: 3px;
    z-index: 100;
    display: flex;
    align-items: center;
  }
  #healthBarFill {
    height: 100%;
    background: linear-gradient(90deg, #00ff00, #00cc00);
    border-radius: 8px;
    transition: width 0.3s ease;
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.6);
  }
  #healthText {
    color: #00ff00;
    font-weight: bold;
    font-size: 11px;
    position: absolute;
    right: 5px;
    text-align: right;
  }
  #energyBar {
    position: fixed;
    top: 95px;
    left: 10px;
    width: 150px;
    height: 20px;
    background: rgba(0, 0, 0, 0.8);
    border: 2px solid #0099ff;
    border-radius: 10px;
    padding: 3px;
    z-index: 100;
    display: flex;
    align-items: center;
  }
  #energyBarFill {
    height: 100%;
    background: linear-gradient(90deg, #0099ff, #00ccff);
    border-radius: 8px;
    transition: width 0.3s ease;
    box-shadow: 0 0 10px rgba(0, 153, 255, 0.6);
  }
  #energyText {
    color: #0099ff;
    font-weight: bold;
    font-size: 11px;
    position: absolute;
    right: 5px;
    text-align: right;
  }
</style>
</head>
<body>

<div id="loginScreen" class="">
  <div id="loginBox">
    <h1>üöÄ AMONG US</h1>
    <input type="text" id="usernameInput" placeholder="Ingresa tu nombre de usuario" maxlength="15">
    <br>
    <button id="loginBtn">ENTRAR AL JUEGO</button>
  </div>
</div>

<div id="userInfo" class="">
  Usuario: <span id="currentUser">user</span>
</div>

<div id="playerCount">
  üë• Jugadores Online: <span id="onlineCount">0</span>
</div>

<div id="killCounter">
  ‚öîÔ∏è Kills: <span id="killCount">0</span>
</div>

<div id="healthBar" class="">
  <div id="healthBarFill" style="width: 100%; background: linear-gradient(90deg, #00ff00, #00cc00);"></div>
  <div id="healthText">500/500</div>
</div>

<div id="energyBar" class="">
  <div id="energyBarFill" style="width: 100%; background: linear-gradient(90deg, #0099ff, #00ccff);"></div>
  <div id="energyText">100/100</div>
</div>

<div id="inventoryBar" class="">
  <div class="inventory-slot active" data-weapon="fist">
    <div>üëä<br>Pu√±o<br><small>Z</small></div>
    <div class="cooldown-overlay" style="height: 0%;"></div>
    <div class="cooldown-text"></div>
  </div>
  <div class="inventory-slot" data-weapon="sword">
    <div>‚öîÔ∏è<br>Espada<br><small>C</small></div>
    <div class="cooldown-overlay" style="height: 0%;"></div>
    <div class="cooldown-text"></div>
  </div>
  <div class="inventory-slot" data-weapon="bow">
    <div>üèπ<br>Arco<br><small>V</small></div>
    <div class="cooldown-overlay" style="height: 0%;"></div>
    <div class="cooldown-text"></div>
  </div>
  <div class="inventory-slot" data-weapon="fireball">
    <div>üî•<br>Fuego<br><small>B</small></div>
    <div class="cooldown-overlay" style="height: 0%;"></div>
    <div class="cooldown-text"></div>
  </div>
</div>

<canvas id="game" width="1600" height="1000"></canvas>

<div id="chatMessages"><div class="chatMsg"><span class="username" style="color:hsl(335.10160560358645, 70%, 60%)">Ola783:</span> Aver matame</div><div class="chatMsg"><span class="username" style="color:hsl(103.08063270411074, 70%, 60%)">Paspias:</span> per</div><div class="chatMsg"><span class="username" style="color:hsl(103.08063270411074, 70%, 60%)">Paspias:</span> hola</div><div class="chatMsg"><span class="username" style="color:hsl(284.50946469035506, 70%, 60%)">Ola783:</span> Porque no puedo morir?</div><div class="chatMsg"><span class="username" style="color:hsl(103.08063270411074, 70%, 60%)">Paspias:</span> reinicia</div><div class="chatMsg"><span class="username" style="color:hsl(284.50946469035506, 70%, 60%)">Ola783:</span> voy</div><div class="chatMsg"><span class="username" style="color:hsl(103.08063270411074, 70%, 60%)">Paspias:</span> la pagina</div><div class="chatMsg"><span class="username" style="color:hsl(270.27399339043194, 70%, 60%)">Ola783:</span> Ya lo hice</div><div class="chatMsg"><span class="username" style="color:hsl(293.0859094721852, 70%, 60%)">Paspias:</span> ya si?</div><div class="chatMsg"><span class="username" style="color:hsl(293.0859094721852, 70%, 60%)">Paspias:</span> eliminame</div><div class="chatMsg"><span class="username" style="color:hsl(270.27399339043194, 70%, 60%)">Ola783:</span> volveme a matar, quiero mandarte algo</div><div class="chatMsg"><span class="username" style="color:hsl(143.8741763534864, 70%, 60%)">Ola783:</span> si?</div><div class="chatMsg"><span class="username" style="color:hsl(316.3253610300013, 70%, 60%)">Paspias:</span> dinero</div><div class="chatMsg"><span class="username" style="color:hsl(206.370661446054, 70%, 60%)">Paspias:</span> como se ve</div><div class="chatMsg"><span class="username" style="color:hsl(231.89982431897832, 70%, 60%)">Ola783:</span> ESTA RE ZARPADO</div><div class="chatMsg"><span class="username" style="color:hsl(206.370661446054, 70%, 60%)">Paspias:</span> oye</div><div class="chatMsg"><span class="username" style="color:hsl(231.89982431897832, 70%, 60%)">Ola783:</span> si?</div><div class="chatMsg"><span class="username" style="color:hsl(206.370661446054, 70%, 60%)">Paspias:</span> mandame foto de la pantalla de muerte</div><div class="chatMsg"><span class="username" style="color:hsl(206.370661446054, 70%, 60%)">Paspias:</span> gg</div><div class="chatMsg"><span class="username" style="color:hsl(140.0391965009375, 70%, 60%)">Paspias:</span> li</div></div>

<div id="chatInput" class="hidden">
  <input type="text" id="chatInputField" placeholder="Escribe un mensaje..." maxlength="100">
  <button id="chatSendBtn">Enviar</button>
</div>

<script type="module">
import { 
    initializeApp 
} from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';

import { 
    getDatabase, ref, set, onValue, remove, get 
} from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

// =====================================================
// CONFIG FIREBASE
// =====================================================
const app = initializeApp({
  apiKey: "AIzaSyClTAw_XLfH3UcCKTisTREZchz41tTxL7g",
  authDomain: "projectmap-382dd.firebaseapp.com",
  databaseURL: "https://projectmap-382dd-default-rtdb.firebaseio.com",
  projectId: "projectmap-382dd",
  storageBucket: "projectmap-382dd.firebasestorage.app",
  messagingSenderId: "1016267509437",
  appId: "1:1016267509437:web:fa243dd82b151383ccb1d4",
  measurementId: "G-4ECYZ37F17"
});

const db = getDatabase(app);

// =====================================================
// VARIABLES DEL JUEGO
// =====================================================
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let myId = null;
let myUsername = null;
let myColor = `hsl(${Math.random()*360}, 70%, 60%)`;

let players = {};
let smoothPlayers = {};

let pos = { x: 400, y: 300 };
let keys = {};
let speed = 2.2;
let playerHealth = 500; // Vida del jugador
let playerEnergy = 100; // Energ√≠a del jugador (para fuego)
const MAX_ENERGY = 100;
const ENERGY_REGEN_RATE = 0.3; // Energ√≠a regenerada por frame
const FIREBALL_ENERGY_COST = 30; // Energ√≠a consumida por bola de fuego
let killStreak = 0; // Contador de muertes consecutivas
let lastKillTime = 0; // Timestamp del √∫ltimo asesinato
const KILLSTREAK_TIMEOUT = 10000; // 10 segundos para mantener la racha activa
let totalKills = 0; // Contador total de kills en la sesi√≥n

// Sistema de Dash
let isDashing = false;
let dashDirection = { x: 0, y: 0 };
let dashSpeed = 8;
let dashDuration = 15; // frames
let dashFrames = 0;
let dashCooldown = 0;
const DASH_COOLDOWN = 40; // frames entre dashes

// Sistema de Escudo Post-Respawn
let hasShield = false;
let shieldTime = 0;
let shieldStartTime = 0;
const SHIELD_DURATION = 3000; // 3 segundos de invulnerabilidad
let shieldTimeoutId = null; // Para limpiar el escudo si se desconecta

let gameStarted = false;

// Variables de ataque
let isAttacking = false;
let attackCooldown = 0;
let targetEnemy = null;

// Cooldowns por arma
let weaponCooldowns = {
    fist: 0,
    sword: 0,
    bow: 0,
    fireball: 0
};

// Variables de arco y bola de fuego
let isAiming = false;
let isManualAiming = false;
let aimAngle = 0;
let arrows = [];
let fireballs = [];
let syncedArrows = [];
let syncedFireballs = [];
let xPressTime = 0;

// Sistema de armas - Se carga desde weapons.json
let currentWeapon = "fist"; // "fist", "sword", "bow" o "fireball"
let weapons = {};
let gameConfig = {};

// Cargar configuraci√≥n desde JSON
async function loadWeaponsConfig() {
    try {
        const response = await fetch('weapons.json');
        const data = await response.json();
        weapons = data.weapons;
        gameConfig = data.gameSettings;
        
        // Actualizar variables globales con los valores del JSON
        playerHealth = gameConfig.playerMaxHealth;
        playerEnergy = gameConfig.playerMaxEnergy;
        
        console.log("‚úÖ Configuraci√≥n de armas cargada desde weapons.json");
    } catch (error) {
        console.error("‚ùå Error al cargar weapons.json:", error);
        // Usar valores por defecto si falla la carga
        loadDefaultWeapons();
    }
}

// Valores por defecto si no se puede cargar el JSON
function loadDefaultWeapons() {
    weapons = {
        fist: {
            name: "Pu√±o",
            range: 150,
            speed: 8,
            cooldown: 30,
            damage: 25,
            energyCost: 0,
            color: "rgba(255, 100, 100, 0.8)"
        },
        sword: {
            name: "Espada",
            range: 200,
            speed: 10,
            cooldown: 15,
            damage: 50,
            energyCost: 0,
            color: "rgba(100, 200, 255, 0.8)"
        },
        bow: {
            name: "Arco",
            range: 400,
            speed: 12,
            cooldown: 20,
            damage: 35,
            energyCost: 0,
            color: "rgba(200, 150, 100, 0.8)"
        },
        fireball: {
            name: "üî• Bola de Fuego",
            range: 300,
            speed: 6,
            cooldown: 60,
            damage: 60,
            energyCost: 30,
            color: "rgba(255, 100, 0, 0.9)"
        }
    };
    gameConfig = {
        playerMaxHealth: 500,
        playerMaxEnergy: 100,
        energyRegenRate: 0.3
    };
}

// Efectos de impacto
let impacts = [];

// Efectos de fuego
let fireEffects = [];

// Efectos de impacto sincronizados
let syncedImpacts = [];

// Estado del chat
let chatOpen = false;

// Variables de eliminaci√≥n
let isEliminated = false;
let eliminationTime = 0;
let eliminatedByName = "";
let disintegrationEffects = [];

// Variables para contador de jugadores
let connectedPlayers = new Set();

// SISTEMA DE LOGIN
// =====================================================
const loginScreen = document.getElementById("loginScreen");
const loginBox = document.getElementById("loginBox");
const usernameInput = document.getElementById("usernameInput");
const loginBtn = document.getElementById("loginBtn");
const userInfo = document.getElementById("userInfo");
const currentUserSpan = document.getElementById("currentUser");
const chatMessagesDiv = document.getElementById("chatMessages");
const chatInput = document.getElementById("chatInput");
const chatInputField = document.getElementById("chatInputField");
const chatSendBtn = document.getElementById("chatSendBtn");
const playerCountDiv = document.getElementById("playerCount");
const onlineCountSpan = document.getElementById("onlineCount");
const killCounterDiv = document.getElementById("killCounter");
const killCountSpan = document.getElementById("killCount");

// Verificar si hay usuario guardado
const savedUsername = localStorage.getItem("amongUsUsername");
if (savedUsername) {
    usernameInput.value = savedUsername;
}

loginBtn.addEventListener("click", startGame);
usernameInput.addEventListener("keypress", (e) => {
    if (e.key === "Enter") startGame();
});

// Auto-iniciar sesi√≥n si hay usuario guardado
window.addEventListener("load", () => {
    const savedUsername = localStorage.getItem("amongUsUsername");
    if (savedUsername) {
        startGame();
    }
});

async function startGame() {
    const username = usernameInput.value.trim();
    
    if (username.length < 3) {
        alert("El nombre debe tener al menos 3 caracteres");
        return;
    }

    // Cargar configuraci√≥n de armas desde JSON
    await loadWeaponsConfig();

    myUsername = username;
    myId = "player_" + username.toLowerCase().replace(/\s+/g, "_");

    // Guardar usuario en localStorage
    localStorage.setItem("amongUsUsername", myUsername);

    // Limpiar cualquier instancia anterior del mismo usuario
    await remove(ref(db, "players/" + myId));
    await new Promise(resolve => setTimeout(resolve, 100));

    // Registrar cuenta en Firebase
    await set(ref(db, "cuentas/" + myId), {
        username: myUsername,
        createdAt: Date.now()
    });

    // Ocultar login y mostrar juego
    loginScreen.classList.add("hidden");
    userInfo.classList.remove("hidden");
    document.getElementById("inventoryBar").classList.remove("hidden");
    document.getElementById("healthBar").classList.remove("hidden");
    currentUserSpan.textContent = myUsername;

    // Reinicializar contador de kills
    totalKills = 0;
    killStreak = 0;
    updateKillCounter();

    gameStarted = true;
    startGameLoop();
    
    // Agregar listeners al inventario
    setupInventoryListeners();
    
    // Iniciar escucha del chat
    listenToChat();
}

// =====================================================
// CONTROLES (WASD + FLECHAS + X PARA ATACAR + Z/C/V PARA CAMBIAR ARMA)
// =====================================================
document.addEventListener("keydown", e => {
    // Abrir/cerrar chat con Enter
    if (e.key === "Enter" && gameStarted) {
        if (!chatOpen) {
            chatOpen = true;
            chatInput.classList.remove("hidden");
            chatMessagesDiv.style.overflow = "auto";
            chatMessagesDiv.classList.add("chatOpen");
            chatInputField.focus();
        }
        return; // No procesar otros controles
    }
    
    // Si el chat est√° abierto, no procesar controles del juego
    if (chatOpen) return;
    
    // Dash con ESPACIO
    if (e.code === "Space" && gameStarted && !isDashing && dashCooldown <= 0) {
        e.preventDefault();
        performDash();
        return;
    }
    
    keys[e.key] = true;
    keys[e.key.toLowerCase()] = true;
    
    // Ataque con X
    if ((e.key === "x" || e.key === "X")) {
        if (currentWeapon === "bow" && !isAiming) {
            xPressTime = Date.now();
            isManualAiming = true;
            isAiming = true;
        } else if (!isAttacking && weaponCooldowns[currentWeapon] <= 0 && currentWeapon !== "bow" && currentWeapon !== "fireball") {
            performAttack();
        }
    }
    
    // Cambiar a pu√±o con Z
    if ((e.key === "z" || e.key === "Z")) {
        currentWeapon = "fist";
        isAiming = false;
        isManualAiming = false;
        updateInventoryUI();
    }
    
    // Cambiar a espada con C
    if ((e.key === "c" || e.key === "C")) {
        currentWeapon = "sword";
        isAiming = false;
        isManualAiming = false;
        updateInventoryUI();
    }
    
    // Cambiar a arco con V
    if ((e.key === "v" || e.key === "V")) {
        currentWeapon = "bow";
        updateInventoryUI();
    }
    
    // Cambiar a bola de fuego con B
    if ((e.key === "b" || e.key === "B")) {
        currentWeapon = "fireball";
        isAiming = false;
        isManualAiming = false;
        updateInventoryUI();
    }
});

document.addEventListener("keyup", e => {
    keys[e.key] = false;
    keys[e.key.toLowerCase()] = false;
    
    // Soltar X dispara la flecha
    if ((e.key === "x" || e.key === "X") && isAiming && currentWeapon === "bow") {
        let pressDuration = Date.now() - xPressTime;
        
        // Si se presion√≥ menos de 300ms, es un click r√°pido (auto-apuntar)
        if (pressDuration < 300) {
            autoAimToClosestEnemy();
        }
        fireArrow();
        isAiming = false;
        isManualAiming = false;
    }
});

// Mouse move para apuntar con el arco (solo si se mantiene presionado)
document.addEventListener("mousemove", (e) => {
    if (isManualAiming && currentWeapon === "bow") {
        let rect = canvas.getBoundingClientRect();
        let mouseX = e.clientX - rect.left;
        let mouseY = e.clientY - rect.top;
        aimAngle = Math.atan2(mouseY - pos.y, mouseX - pos.x);
    }
});

// Click del mouse para lanzar bola de fuego
canvas.addEventListener("click", (e) => {
    if (gameStarted && !chatOpen && currentWeapon === "fireball" && weaponCooldowns["fireball"] <= 0 && playerEnergy >= FIREBALL_ENERGY_COST) {
        let rect = canvas.getBoundingClientRect();
        let clickX = e.clientX - rect.left;
        let clickY = e.clientY - rect.top;
        
        // Consumir energ√≠a
        playerEnergy -= FIREBALL_ENERGY_COST;
        if (playerEnergy < 0) playerEnergy = 0;
        
        // Crear efecto de fuego instant√°neamente donde se hizo click
        fireEffects.push({
            x: clickX,
            y: clickY,
            life: 500,
            maxLife: 500,
            radius: 50
        });
        
        // Enviar efecto de fuego a Firebase
        const fireballId = "fireball_" + Date.now() + "_" + Math.floor(Math.random() * 1000000);
        set(ref(db, "fireballs/" + fireballId), {
            x: clickX,
            y: clickY,
            angle: 0,
            speed: 0,
            playerId: myId,
            damage: weapons["fireball"].damage,
            timestamp: Date.now()
        }).catch(err => console.error("Error al enviar bola de fuego:", err));
        
        weaponCooldowns["fireball"] = weapons["fireball"].cooldown;
    }
});

// =====================================================
// SISTEMA DE ESCUDO POST-RESPAWN
// =====================================================
function activateShield() {
    // Limpiar timeout anterior si existe
    if (shieldTimeoutId !== null) {
        clearTimeout(shieldTimeoutId);
    }
    
    hasShield = true;
    shieldStartTime = Date.now();
    shieldTime = SHIELD_DURATION;
    
    // Auto-desactivar escudo despu√©s de 3 segundos
    shieldTimeoutId = setTimeout(() => {
        hasShield = false;
        shieldTimeoutId = null;
    }, SHIELD_DURATION);
}

function deactivateShield() {
    hasShield = false;
    shieldTime = 0;
    if (shieldTimeoutId !== null) {
        clearTimeout(shieldTimeoutId);
        shieldTimeoutId = null;
    }
}

// =====================================================
// SISTEMA DE DASH
// =====================================================
function performDash() {
    // Determinar direcci√≥n del dash basada en las teclas presionadas
    let dirX = 0;
    let dirY = 0;
    
    if (keys["w"] || keys["W"] || keys["ArrowUp"]) dirY -= 1;
    if (keys["s"] || keys["S"] || keys["ArrowDown"]) dirY += 1;
    if (keys["a"] || keys["A"] || keys["ArrowLeft"]) dirX -= 1;
    if (keys["d"] || keys["D"] || keys["ArrowRight"]) dirX += 1;
    
    // Si no hay direcci√≥n, usar la √∫ltima direcci√≥n o hacia la derecha
    if (dirX === 0 && dirY === 0) {
        dirX = 1;
    }
    
    // Normalizar direcci√≥n
    let magnitude = Math.sqrt(dirX * dirX + dirY * dirY);
    dashDirection.x = dirX / magnitude;
    dashDirection.y = dirY / magnitude;
    
    isDashing = true;
    dashFrames = 0;
}

function autoAimToClosestEnemy() {
    let weapon = weapons["bow"];
    let closestEnemy = null;
    let closestDistance = weapon.range;
    
    for (let id in smoothPlayers) {
        if (id === myId) continue;
        
        let enemy = smoothPlayers[id];
        let dx = enemy.x - pos.x;
        let dy = enemy.y - pos.y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < closestDistance) {
            closestDistance = distance;
            closestEnemy = { x: enemy.x, y: enemy.y };
        }
    }
    
    if (closestEnemy) {
        let dx = closestEnemy.x - pos.x;
        let dy = closestEnemy.y - pos.y;
        aimAngle = Math.atan2(dy, dx);
    }
}

// =====================================================
// SISTEMA DE ATAQUE
// =====================================================
function performAttack() {
    let weapon = weapons[currentWeapon];
    
    // Encontrar enemigo m√°s cercano
    let closestEnemy = null;
    let closestDistance = weapon.range;
    
    for (let id in smoothPlayers) {
        if (id === myId) continue;
        
        let enemy = smoothPlayers[id];
        let dx = enemy.x - pos.x;
        let dy = enemy.y - pos.y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < closestDistance) {
            closestDistance = distance;
            closestEnemy = { id, enemy, dx, dy, distance };
        }
    }
    
    if (closestEnemy) {
        isAttacking = true;
        targetEnemy = closestEnemy;
        weaponCooldowns[currentWeapon] = weapon.cooldown;
    }
}

function updateAttack() {
    if (isAttacking && targetEnemy) {
        let weapon = weapons[currentWeapon];
        let dx = targetEnemy.enemy.x - pos.x;
        let dy = targetEnemy.enemy.y - pos.y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        
        // Moverse hacia el enemigo
        if (distance > 20) {
            let angle = Math.atan2(dy, dx);
            pos.x += Math.cos(angle) * weapon.speed;
            pos.y += Math.sin(angle) * weapon.speed;
        } else {
            // Lleg√≥ al enemigo, crear impacto
            if (currentWeapon === "fireball") {
                // Crear efecto de fuego
                fireEffects.push({
                    x: targetEnemy.enemy.x,
                    y: targetEnemy.enemy.y,
                    life: 500,
                    maxLife: 500,
                    radius: 50
                });
            } else {
                // Enviar impacto a Firebase para pu√±o y espada
                const impactId = "impact_" + Date.now() + "_" + Math.floor(Math.random() * 1000000);
                const damage = weapons[currentWeapon].damage;
                set(ref(db, "impacts/" + impactId), {
                    x: targetEnemy.enemy.x,
                    y: targetEnemy.enemy.y,
                    life: 20,
                    maxLife: 20,
                    damage: damage,
                    targetId: targetEnemy.id,
                    attackerId: myId,
                    timestamp: Date.now(),
                    killProcessed: false
                }).catch(err => console.error("Error al enviar impacto:", err));
                
                impacts.push({
                    x: targetEnemy.enemy.x,
                    y: targetEnemy.enemy.y,
                    life: 20,
                    maxLife: 20,
                    targetId: targetEnemy.id
                });
                
                // Crear efecto de desintegraci√≥n local si el enemigo muere
                // (se ver√° cuando recibas la confirmaci√≥n de Firebase)
            }
            isAttacking = false;
            targetEnemy = null;
        }
    }
    
    // Actualizar flechas
    for (let i = arrows.length - 1; i >= 0; i--) {
        let arrow = arrows[i];
        arrow.x += Math.cos(arrow.angle) * arrow.speed;
        arrow.y += Math.sin(arrow.angle) * arrow.speed;
        
        // Eliminar si sale del mapa
        if (arrow.x < 0 || arrow.x > canvas.width || arrow.y < 0 || arrow.y > canvas.height) {
            arrows.splice(i, 1);
            continue;
        }
        
        // Detectar colisi√≥n con enemigos
        for (let id in smoothPlayers) {
            if (id === myId) continue;
            
            let enemy = smoothPlayers[id];
            let dx = enemy.x - arrow.x;
            let dy = enemy.y - arrow.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 20) {
                // Enviar impacto a Firebase
                const impactId = "impact_" + Date.now() + "_" + Math.floor(Math.random() * 1000000);
                const damage = weapons["bow"].damage;
                set(ref(db, "impacts/" + impactId), {
                    x: arrow.x,
                    y: arrow.y,
                    life: 20,
                    maxLife: 20,
                    damage: damage,
                    targetId: id,
                    attackerId: myId,
                    timestamp: Date.now(),
                    killProcessed: false
                }).catch(err => console.error("Error al enviar impacto:", err));
                
                impacts.push({
                    x: arrow.x,
                    y: arrow.y,
                    life: 20,
                    maxLife: 20
                });
                arrows.splice(i, 1);
                weaponCooldowns["bow"] = weapons["bow"].cooldown;
                break;
            }
        }
    }
    
    // Actualizar bolas de fuego
    for (let i = fireballs.length - 1; i >= 0; i--) {
        let fireball = fireballs[i];
        fireball.x += Math.cos(fireball.angle) * fireball.speed;
        fireball.y += Math.sin(fireball.angle) * fireball.speed;
        
        // Eliminar si sale del mapa
        if (fireball.x < 0 || fireball.x > canvas.width || fireball.y < 0 || fireball.y > canvas.height) {
            fireballs.splice(i, 1);
            continue;
        }
        
        // Detectar colisi√≥n con enemigos
        for (let id in smoothPlayers) {
            if (id === myId) continue;
            let enemy = smoothPlayers[id];
            let dx = enemy.x - fireball.x;
            let dy = enemy.y - fireball.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 20) {
                // Crear efecto de fuego localmente (solo para quien lanz√≥)
                fireEffects.push({
                    x: fireball.x,
                    y: fireball.y,
                    life: 300,
                    maxLife: 300,
                    radius: 50
                });
                
                fireballs.splice(i, 1);
                weaponCooldowns["fireball"] = weapons["fireball"].cooldown;
                break;
            }
        }
        
        fireball.life--;
        if (fireball.life <= 0) {
            fireballs.splice(i, 1);
        }
    }
    
    // Actualizar impactos
    for (let i = impacts.length - 1; i >= 0; i--) {
        impacts[i].life--;
        if (impacts[i].life <= 0) {
            impacts.splice(i, 1);
        }
    }
    
    // Actualizar flechas sincronizadas (de otros jugadores)
    for (let i = syncedArrows.length - 1; i >= 0; i--) {
        let arrow = syncedArrows[i];
        arrow.x += Math.cos(arrow.angle) * arrow.speed;
        arrow.y += Math.sin(arrow.angle) * arrow.speed;
        
        // Eliminar si sale del mapa
        if (arrow.x < 0 || arrow.x > canvas.width || arrow.y < 0 || arrow.y > canvas.height) {
            syncedArrows.splice(i, 1);
        }
    }
    
    // Actualizar bolas de fuego sincronizadas (de otros jugadores)
    for (let i = syncedFireballs.length - 1; i >= 0; i--) {
        let fireball = syncedFireballs[i];
        // Decrementar vida
        if (!fireball.life) {
            fireball.life = 300; // Inicializar vida si no existe
        }
        fireball.life--;
        
        // Eliminar si sale del mapa o se acaba la vida
        if (fireball.x < 0 || fireball.x > canvas.width || fireball.y < 0 || fireball.y > canvas.height || fireball.life <= 0) {
            syncedFireballs.splice(i, 1);
        }
    }
    
    // Reducir cooldowns de todas las armas
    for (let weapon in weaponCooldowns) {
        if (weaponCooldowns[weapon] > 0) {
            weaponCooldowns[weapon]--;
        }
    }
}

function fireArrow() {
    const arrowData = {
        x: pos.x,
        y: pos.y,
        angle: aimAngle,
        speed: 7
    };
    arrows.push(arrowData);
    
    // Enviar flecha a Firebase
    const arrowId = "arrow_" + Date.now() + "_" + Math.floor(Math.random() * 1000000);
    set(ref(db, "arrows/" + arrowId), {
        x: arrowData.x,
        y: arrowData.y,
        angle: arrowData.angle,
        speed: arrowData.speed,
        playerId: myId,
        timestamp: Date.now()
    }).catch(err => console.error("Error al enviar flecha:", err));
    
    weaponCooldowns["bow"] = weapons["bow"].cooldown;
}

function fireFireball() {
    const fireballData = {
        x: pos.x,
        y: pos.y,
        angle: aimAngle,
        speed: 5,
        life: 500, // Duraci√≥n m√°s larga
        maxLife: 500,
        radius: 50
    };
    fireballs.push(fireballData);
    
    // Enviar bola de fuego a Firebase
    const fireballId = "fireball_" + Date.now() + "_" + Math.floor(Math.random() * 1000000);
    set(ref(db, "fireballs/" + fireballId), {
        x: fireballData.x,
        y: fireballData.y,
        angle: fireballData.angle,
        speed: fireballData.speed,
        playerId: myId,
        timestamp: Date.now()
    }).catch(err => console.error("Error al enviar bola de fuego:", err));
}

// =====================================================
// MOVIMIENTO LOCAL
// =====================================================
function updateMovement() {
    // Actualizar dash
    if (isDashing) {
        pos.x += dashDirection.x * dashSpeed;
        pos.y += dashDirection.y * dashSpeed;
        dashFrames++;
        
        if (dashFrames >= dashDuration) {
            isDashing = false;
            dashFrames = 0;
            dashCooldown = DASH_COOLDOWN;
        }
    }
    
    // WASD (solo si no est√° haciendo dash)
    if (!isDashing) {
        if (keys["w"] || keys["W"] || keys["ArrowUp"]) pos.y -= speed;
        if (keys["s"] || keys["S"] || keys["ArrowDown"]) pos.y += speed;
        if (keys["a"] || keys["A"] || keys["ArrowLeft"]) pos.x -= speed;
        if (keys["d"] || keys["D"] || keys["ArrowRight"]) pos.x += speed;
    }
    
    // Reducir cooldown del dash
    if (dashCooldown > 0) {
        dashCooldown--;
    }
    
    // Regenerar energ√≠a
    playerEnergy += ENERGY_REGEN_RATE;
    if (playerEnergy > MAX_ENERGY) {
        playerEnergy = MAX_ENERGY;
    }

    pos.x = Math.max(20, Math.min(canvas.width - 20, pos.x));
    pos.y = Math.max(20, Math.min(canvas.height - 20, pos.y));
}

// =====================================================
// ENVIAR POSICI√ìN A FIREBASE
// =====================================================
function startGameLoop() {
    setInterval(() => {
        if (gameStarted) {
            set(ref(db, "players/" + myId), {
                x: pos.x,
                y: pos.y,
                color: myColor,
                username: myUsername,
                health: playerHealth
            });
        }
    }, 150);

    // =====================================================
    // ESCUCHAR PLAYERS
    // =====================================================
    onValue(ref(db, "players"), snapshot => {
        players = snapshot.val() || {};

        for (let id in players) {
            if (!smoothPlayers[id]) {
                smoothPlayers[id] = { 
                    x: players[id].x,
                    y: players[id].y,
                    color: players[id].color,
                    username: players[id].username,
                    health: players[id].health
                };
            }
        }

        // Limpiar jugadores que ya no existen (fueron eliminados)
        for (let id in smoothPlayers) {
            if (!players[id]) {
                // Crear efecto de desintegraci√≥n cuando un jugador desaparece
                createDisintegrationEffect(smoothPlayers[id].x, smoothPlayers[id].y, smoothPlayers[id].color);
                
                delete smoothPlayers[id];
            }
        }
        
        // Actualizar contador de jugadores y notificaciones
        updatePlayerCount();
    });

    // =====================================================
    // ESCUCHAR EFECTOS DE FUEGO
    // =====================================================
    onValue(ref(db, "fireEffects"), snapshot => {
        const effects = snapshot.val() || {};
        fireEffects = [];
        
        for (let id in effects) {
            let effect = effects[id];
            fireEffects.push({
                x: effect.x,
                y: effect.y,
                life: effect.life,
                maxLife: effect.maxLife,
                radius: effect.radius
            });
        }
        
        // Limpiar efectos antiguos (mantener solo los √∫ltimos 20)
        if (Object.keys(effects).length > 20) {
            const effectIds = Object.keys(effects);
            const toDelete = effectIds.slice(0, effectIds.length - 20);
            toDelete.forEach(id => {
                remove(ref(db, "fireEffects/" + id)).catch(err => console.error("Error al eliminar efecto:", err));
            });
        }
    });

    // =====================================================
    // ESCUCHAR IMPACTOS
    // =====================================================
    onValue(ref(db, "impacts"), snapshot => {
        const impactsData = snapshot.val() || {};
        syncedImpacts = [];
        
        for (let id in impactsData) {
            let impact = impactsData[id];
            
            // Detectar cuando YO elimino a alguien (impacto que yo lanc√©)
            if (impact.attackerId === myId && impact.targetId && !impact.killProcessed && players[impact.targetId] && players[impact.targetId].health <= 0) {
                // Marcar como procesado para no contar m√∫ltiples veces
                set(ref(db, "impacts/" + id + "/killProcessed"), true).catch(err => console.error("Error al marcar kill:", err));
                
                // Incrementar kills INMEDIATAMENTE
                totalKills++;
                killStreak++;
                lastKillTime = Date.now();
                updateKillCounter();
                
                // Enviar mensaje de kill al chat
                const victimName = players[impact.targetId]?.username || "Desconocido";
                const msgId = "msg_" + Date.now() + "_" + Math.floor(Math.random() * 1000000);
                set(ref(db, "messages/" + msgId), {
                    username: "‚öîÔ∏è SISTEMA",
                    message: `${myUsername} ha eliminado a ${victimName}`,
                    color: "#ff6600",
                    timestamp: Date.now()
                }).catch(err => console.error("Error al enviar mensaje de kill:", err));
            }
            
            // NOTA: El killstreak se incrementa cuando el jugador es eliminado (health <= 0)
            // No aqu√≠, porque aqu√≠ se cuenta cada impacto/da√±o
            // Se incrementa correctamente en el listener de players cuando detecta que un jugador desapareci√≥
            
            // Aplicar da√±o si el impacto es dirigido a nosotros (pero no si tiene escudo)
            if (impact.targetId === myId && impact.damage && !impact.processed) {
                // No aplicar da√±o si tiene escudo activo
                if (!hasShield) {
                    playerHealth -= impact.damage;
                    if (playerHealth < 0) playerHealth = 0;
                }
                
                // Marcar como procesado
                set(ref(db, "impacts/" + id + "/processed"), true).catch(err => console.error("Error al marcar impacto:", err));
                
                // Reiniciar killstreak cuando recibimos da√±o que nos mata
                if (playerHealth <= 0) {
                    killStreak = 0;
                }
                
                // Verificar si el jugador fue eliminado
                if (playerHealth <= 0 && gameStarted) {
                    gameStarted = false;
                    isEliminated = true;
                    eliminationTime = Date.now();
                    eliminatedByName = "Desconocido";
                    
                    // Obtener el nombre del atacante
                    get(ref(db, "players")).then(snapshot => {
                        const allPlayers = snapshot.val() || {};
                        for (let playerId in allPlayers) {
                            if (playerId === impact.attackerId) {
                                eliminatedByName = allPlayers[playerId].username || "Desconocido";
                                
                                // Enviar mensaje de eliminaci√≥n al chat
                                const msgId = "msg_" + Date.now() + "_" + Math.floor(Math.random() * 1000000);
                                set(ref(db, "messages/" + msgId), {
                                    username: "‚öîÔ∏è SISTEMA",
                                    message: `${eliminatedByName} ha eliminado a ${myUsername}`,
                                    color: "#ff6600",
                                    timestamp: Date.now()
                                }).catch(err => console.error("Error al enviar mensaje de eliminaci√≥n:", err));
                                
                                break;
                            }
                        }
                    });
                    
                    // Crear efecto de desintegraci√≥n
                    createDisintegrationEffect(pos.x, pos.y, myColor);
                    
                    // Eliminar al jugador de Firebase
                    remove(ref(db, "players/" + myId)).catch(err => console.error("Error al eliminar jugador:", err));
                    
                    // Respawnear despu√©s de 4 segundos
                    setTimeout(() => {
                        playerHealth = 500;
                        playerEnergy = MAX_ENERGY;
                        pos = { x: 600, y: 400 };
                        gameStarted = true;
                        isEliminated = false;
                        
                        // Activar escudo post-respawn
                        activateShield();
                        
                        // Registrar de nuevo en Firebase
                        set(ref(db, "players/" + myId), {
                            x: pos.x,
                            y: pos.y,
                            color: myColor,
                            username: myUsername,
                            health: playerHealth
                        }).catch(err => console.error("Error al respawnear:", err));
                    }, 4000);
                    
                    // Reiniciar killstreak cuando mueres
                    killStreak = 0;
                }
            }
            
            
            // Decrementar vida del impacto
            let newLife = impact.life - 1;
            
            if (newLife <= 0) {
                // Eliminar impacto cuando su vida llega a 0
                remove(ref(db, "impacts/" + id)).catch(err => console.error("Error al eliminar impacto:", err));
            } else {
                // Actualizar vida en Firebase
                set(ref(db, "impacts/" + id + "/life"), newLife).catch(err => console.error("Error al actualizar vida:", err));
                
                syncedImpacts.push({
                    x: impact.x,
                    y: impact.y,
                    life: newLife,
                    maxLife: impact.maxLife
                });
            }
        }
    });

    // =====================================================
    // ESCUCHAR FLECHAS
    // =====================================================
    onValue(ref(db, "arrows"), snapshot => {
        const arrowsData = snapshot.val() || {};
        syncedArrows = [];
        
        for (let id in arrowsData) {
            let arrow = arrowsData[id];
            // Solo mostrar flechas de otros jugadores
            if (arrow.playerId !== myId) {
                syncedArrows.push({
                    id: id,
                    x: arrow.x,
                    y: arrow.y,
                    angle: arrow.angle,
                    speed: arrow.speed,
                    playerId: arrow.playerId,
                    timestamp: arrow.timestamp
                });
            }
        }
        
        // Limpiar flechas antiguas (m√°s de 5 segundos)
        const now = Date.now();
        for (let id in arrowsData) {
            if (now - arrowsData[id].timestamp > 5000) {
                remove(ref(db, "arrows/" + id)).catch(err => console.error("Error al eliminar flecha:", err));
            }
        }
    });

    // =====================================================
    // ESCUCHAR BOLAS DE FUEGO
    // =====================================================
    onValue(ref(db, "fireballs"), snapshot => {
        const fireballsData = snapshot.val() || {};
        syncedFireballs = [];
        
        for (let id in fireballsData) {
            let fireball = fireballsData[id];
            
            // Aplicar da√±o si la bola de fuego nos golpea (pero no si tiene escudo)
            if (fireball.damage && !fireball.processed) {
                let dx = fireball.x - pos.x;
                let dy = fireball.y - pos.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 60) { // Radio de da√±o de la bola de fuego
                    // No aplicar da√±o si tiene escudo activo
                    if (!hasShield) {
                        playerHealth -= fireball.damage;
                        if (playerHealth < 0) playerHealth = 0;
                    }
                    
                    // Marcar como procesado
                    set(ref(db, "fireballs/" + id + "/processed"), true).catch(err => console.error("Error al marcar fireball:", err));
                }
            }
            
            // Solo mostrar bolas de fuego de otros jugadores
            if (fireball.playerId !== myId) {
                syncedFireballs.push({
                    id: id,
                    x: fireball.x,
                    y: fireball.y,
                    angle: fireball.angle,
                    speed: fireball.speed,
                    playerId: fireball.playerId,
                    timestamp: fireball.timestamp
                });
            }
        }
        
        // Limpiar bolas de fuego antiguas (m√°s de 5 segundos)
        const now2 = Date.now();
        for (let id in fireballsData) {
            if (now2 - fireballsData[id].timestamp > 5000) {
                remove(ref(db, "fireballs/" + id)).catch(err => console.error("Error al eliminar bola de fuego:", err));
            }
        }
    });

    loop();
}

// =====================================================
// INTERPOLACI√ìN
// =====================================================
function interpolate() {
    for (let id in players) {
        let target = players[id];
        let sm = smoothPlayers[id];
        if (!sm) continue;

        sm.x += (target.x - sm.x) * 0.1;
        sm.y += (target.y - sm.y) * 0.1;
        sm.color = target.color;
        sm.username = target.username;
        sm.health = target.health;
    }
}

// =====================================================
// DIBUJAR
// =====================================================
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let id in smoothPlayers) {
        let p = smoothPlayers[id];

        // Cuerpo del jugador
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 15, 0, Math.PI * 2);
        ctx.fill();

        // Borde si es el jugador local
        if (id === myId) {
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 17, 0, Math.PI * 2);
            ctx.stroke();
            
            // Efecto de escudo post-respawn
            if (hasShield) {
                let shieldProgress = (Date.now() - shieldStartTime) / SHIELD_DURATION;
                let shieldOpacity = Math.max(0, 1 - shieldProgress);
                let shieldRadius = 25 + Math.sin(Date.now() / 100) * 3;
                
                // Aura azul pulsante del escudo
                ctx.strokeStyle = `rgba(0, 200, 255, ${shieldOpacity * 0.8})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(p.x, p.y, shieldRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                // C√≠rculos adicionales del escudo
                ctx.strokeStyle = `rgba(100, 220, 255, ${shieldOpacity * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(p.x, p.y, shieldRadius - 5, 0, Math.PI * 2);
                ctx.stroke();
                
                // Texto del escudo
                ctx.fillStyle = `rgba(0, 200, 255, ${shieldOpacity})`;
                ctx.font = "bold 12px Arial";
                ctx.textAlign = "center";
                const shieldTimeRemaining = Math.max(0, SHIELD_DURATION - (Date.now() - shieldStartTime));
                ctx.fillText(`üõ°Ô∏è ${(shieldTimeRemaining / 1000).toFixed(1)}s`, p.x, p.y + 45);
            }
            
            // Efecto de ataque
            if (isAttacking && targetEnemy) {
                // L√≠nea de ataque hacia el enemigo
                ctx.strokeStyle = "rgba(255, 100, 100, 0.8)";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(targetEnemy.enemy.x, targetEnemy.enemy.y);
                ctx.stroke();
                
                // Aura roja pulsante
                let pulse = Math.sin(Date.now() / 100) * 5 + 25;
                ctx.strokeStyle = "rgba(255, 50, 50, 0.6)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(p.x, p.y, pulse, 0, Math.PI * 2);
                ctx.stroke();
                
                // Texto de ataque
                ctx.fillStyle = "rgba(255, 100, 100, 1)";
                ctx.font = "bold 16px Arial";
                ctx.textAlign = "center";
                ctx.fillText("‚öî ATACANDO", p.x, p.y + 35);
            }
        }

        // Nombre del jugador
        ctx.fillStyle = "#fff";
        ctx.font = "bold 12px Arial";
        ctx.textAlign = "center";
        const displayName = id === myId ? p.username + " (T√∫)" : p.username;
        ctx.fillText(displayName, p.x, p.y - 25);
        
        // Barra de vida
        ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
        ctx.fillRect(p.x - 20, p.y - 40, 40, 5);
        ctx.fillStyle = "rgba(0, 255, 0, 0.8)";
        ctx.fillRect(p.x - 20, p.y - 40, (p.health / 500) * 40, 5);
    }
    
    // Dibujar impactos locales
    for (let impact of impacts) {
        let progress = 1 - (impact.life / impact.maxLife);
        let radius = 10 + progress * 40;
        let opacity = 1 - progress;
        
        // C√≠rculo de impacto expandi√©ndose
        ctx.strokeStyle = `rgba(255, 200, 0, ${opacity * 0.8})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(impact.x, impact.y, radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // C√≠rculo interior m√°s peque√±o
        ctx.strokeStyle = `rgba(255, 100, 0, ${opacity})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(impact.x, impact.y, radius * 0.6, 0, Math.PI * 2);
        ctx.stroke();
        
        // Rayos de impacto
        ctx.strokeStyle = `rgba(255, 150, 0, ${opacity * 0.6})`;
        ctx.lineWidth = 2;
        for (let i = 0; i < 8; i++) {
            let angle = (Math.PI * 2 / 8) * i;
            let x1 = impact.x + Math.cos(angle) * radius * 0.5;
            let y1 = impact.y + Math.sin(angle) * radius * 0.5;
            let x2 = impact.x + Math.cos(angle) * radius * 1.2;
            let y2 = impact.y + Math.sin(angle) * radius * 1.2;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
    }
    
    // Dibujar impactos sincronizados desde Firebase
    for (let impact of syncedImpacts) {
        let progress = 1 - (impact.life / impact.maxLife);
        let radius = 10 + progress * 40;
        let opacity = 1 - progress;
        
        // C√≠rculo de impacto expandi√©ndose
        ctx.strokeStyle = `rgba(255, 200, 0, ${opacity * 0.8})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(impact.x, impact.y, radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // C√≠rculo interior m√°s peque√±o
        ctx.strokeStyle = `rgba(255, 100, 0, ${opacity})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(impact.x, impact.y, radius * 0.6, 0, Math.PI * 2);
        ctx.stroke();
        
        // Rayos de impacto
        ctx.strokeStyle = `rgba(255, 150, 0, ${opacity * 0.6})`;
        ctx.lineWidth = 2;
        for (let i = 0; i < 8; i++) {
            let angle = (Math.PI * 2 / 8) * i;
            let x1 = impact.x + Math.cos(angle) * radius * 0.5;
            let y1 = impact.y + Math.sin(angle) * radius * 0.5;
            let x2 = impact.x + Math.cos(angle) * radius * 1.2;
            let y2 = impact.y + Math.sin(angle) * radius * 1.2;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
    }
    
    // Dibujar efectos de fuego
    for (let i = fireEffects.length - 1; i >= 0; i--) {
        let fire = fireEffects[i];
        let progress = 1 - (fire.life / fire.maxLife);
        let opacity = Math.cos(progress * Math.PI) * 0.8; // Efecto pulsante
        
        // C√≠rculo principal de fuego
        ctx.fillStyle = `rgba(255, 100, 0, ${opacity * 0.6})`;
        ctx.beginPath();
        ctx.arc(fire.x, fire.y, fire.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Borde del fuego
        ctx.strokeStyle = `rgba(255, 150, 0, ${opacity})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(fire.x, fire.y, fire.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Part√≠culas de fuego
        for (let p = 0; p < 8; p++) {
            let angle = (Math.PI * 2 / 8) * p + progress * Math.PI;
            let distance = fire.radius * (0.7 + Math.sin(progress * Math.PI * 2) * 0.3);
            let px = fire.x + Math.cos(angle) * distance;
            let py = fire.y + Math.sin(angle) * distance;
            
            // Part√≠cula peque√±a
            ctx.fillStyle = `rgba(255, ${200 - progress * 100}, 0, ${opacity * 0.8})`;
            ctx.beginPath();
            ctx.arc(px, py, 5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        fire.life--;
        if (fire.life <= 0) {
            fireEffects.splice(i, 1);
        }
    }
    
    // Dibujar flechas
    for (let arrow of arrows) {
        ctx.save();
        ctx.translate(arrow.x, arrow.y);
        ctx.rotate(arrow.angle);
        
        // Punta de la flecha
        ctx.fillStyle = "rgba(200, 150, 100, 0.9)";
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-8, -4);
        ctx.lineTo(-8, 4);
        ctx.closePath();
        ctx.fill();
        
        // Tallo de la flecha
        ctx.strokeStyle = "rgba(180, 120, 80, 0.9)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-12, 0);
        ctx.stroke();
        
        ctx.restore();
    }
    
    // Dibujar flechas sincronizadas desde otros jugadores
    for (let arrow of syncedArrows) {
        ctx.save();
        ctx.translate(arrow.x, arrow.y);
        ctx.rotate(arrow.angle);
        
        // Punta de la flecha
        ctx.fillStyle = "rgba(200, 150, 100, 0.7)";
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-8, -4);
        ctx.lineTo(-8, 4);
        ctx.closePath();
        ctx.fill();
        
        // Tallo de la flecha
        ctx.strokeStyle = "rgba(180, 120, 80, 0.7)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-12, 0);
        ctx.stroke();
        
        ctx.restore();
    }
    
    // Dibujar bolas de fuego sincronizadas desde otros jugadores (efecto de fuego completo)
    for (let fireball of syncedFireballs) {
        let progress = (Date.now() % 1000) / 1000; // Animaci√≥n basada en el tiempo actual
        let opacity = Math.cos(progress * Math.PI) * 0.8; // Efecto pulsante
        
        // C√≠rculo principal de fuego
        ctx.fillStyle = `rgba(255, 100, 0, ${opacity * 0.6})`;
        ctx.beginPath();
        ctx.arc(fireball.x, fireball.y, 50, 0, Math.PI * 2);
        ctx.fill();
        
        // Borde del fuego
        ctx.strokeStyle = `rgba(255, 150, 0, ${opacity})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(fireball.x, fireball.y, 50, 0, Math.PI * 2);
        ctx.stroke();
        
        // Part√≠culas de fuego animadas
        for (let p = 0; p < 8; p++) {
            let angle = (Math.PI * 2 / 8) * p + progress * Math.PI;
            let distance = 50 * (0.7 + Math.sin(progress * Math.PI * 2) * 0.3);
            let px = fireball.x + Math.cos(angle) * distance;
            let py = fireball.y + Math.sin(angle) * distance;
            
            // Part√≠cula peque√±a
            ctx.fillStyle = `rgba(255, ${200 - progress * 100}, 0, ${opacity * 0.8})`;
            ctx.beginPath();
            ctx.arc(px, py, 5, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    // Indicador de apunter√≠a solo si se mantiene presionado (apunter√≠a manual)
    if (isManualAiming && (currentWeapon === "bow" || currentWeapon === "fireball")) {
        // L√≠nea de apunter√≠a
        let aimDistance = 150;
        let aimEndX = pos.x + Math.cos(aimAngle) * aimDistance;
        let aimEndY = pos.y + Math.sin(aimAngle) * aimDistance;
        
        ctx.strokeStyle = "rgba(255, 200, 0, 0.6)";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        ctx.lineTo(aimEndX, aimEndY);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // C√≠rculo de apunter√≠a
        ctx.strokeStyle = "rgba(255, 200, 0, 0.8)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(aimEndX, aimEndY, 15, 0, Math.PI * 2);
        ctx.stroke();
        
        // Punto central
        ctx.fillStyle = "rgba(255, 200, 0, 1)";
        ctx.beginPath();
        ctx.arc(aimEndX, aimEndY, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Dibujar bolas de fuego en vuelo (solo visible para quien las lanza)
    for (let fireball of fireballs) {
        // C√≠rculo de fuego
        ctx.fillStyle = "rgba(255, 100, 0, 0.8)";
        ctx.beginPath();
        ctx.arc(fireball.x, fireball.y, 12, 0, Math.PI * 2);
        ctx.fill();
        
        // Borde brillante
        ctx.strokeStyle = "rgba(255, 200, 0, 1)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(fireball.x, fireball.y, 12, 0, Math.PI * 2);
        ctx.stroke();
        
        // Part√≠culas peque√±as alrededor
        for (let p = 0; p < 4; p++) {
            let angle = (Math.PI * 2 / 4) * p;
            let px = fireball.x + Math.cos(angle) * 18;
            let py = fireball.y + Math.sin(angle) * 18;
            ctx.fillStyle = "rgba(255, 150, 0, 0.6)";
            ctx.beginPath();
        }
    }
    
    // Dibujar efectos de desintegraci√≥n (estilo Geometry Dash)
    for (let i = disintegrationEffects.length - 1; i >= 0; i--) {
        let particle = disintegrationEffects[i];
        
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vy += 0.3; // Gravedad
        particle.vx *= 0.98; // Fricci√≥n del aire
        particle.rotation += particle.rotationSpeed;
        
        let progress = 1 - (particle.life / particle.maxLife);
        let opacity = Math.max(0, 1 - progress * 1.2); // Desvanecimiento r√°pido
        
        // Escala decreciente
        particle.scaleX = 1 - progress * 0.3;
        particle.scaleY = 1 - progress * 0.3;
        
        ctx.save();
        ctx.translate(particle.x, particle.y);
        ctx.rotate(particle.rotation);
        ctx.scale(particle.scaleX, particle.scaleY);
        
        // Cuadrado principal con brillo
        ctx.fillStyle = particle.color;
        ctx.globalAlpha = opacity * 0.9;
        ctx.fillRect(-particle.size/2, -particle.size/2, particle.size, particle.size);
        
        // Borde brillante
        ctx.strokeStyle = "rgba(255, 255, 255, " + (opacity * 0.6) + ")";
        ctx.lineWidth = 2;
        ctx.strokeRect(-particle.size/2, -particle.size/2, particle.size, particle.size);
        
        // Brillo interior
        ctx.fillStyle = "rgba(255, 255, 255, " + (opacity * 0.3) + ")";
        ctx.fillRect(-particle.size/4, -particle.size/4, particle.size/2, particle.size/2);
        
        ctx.restore();
        
        particle.life--;
        if (particle.life <= 0) {
            disintegrationEffects.splice(i, 1);
        }
    }
    
    // Mostrar arma actual
    let weapon = weapons[currentWeapon];
    ctx.fillStyle = weapon.color;
    ctx.font = "bold 14px Arial";
    ctx.textAlign = "left";
    ctx.fillText(`Arma: ${weapon.name}`, 10, canvas.height - 10);
    
    // Mostrar killstreak si est√° activo
    if (killStreak > 0 && Date.now() - lastKillTime < KILLSTREAK_TIMEOUT) {
        ctx.fillStyle = "rgba(255, 100, 0, 0.9)";
        ctx.font = "bold 48px Arial";
        ctx.textAlign = "center";
        ctx.textShadow = "0 0 10px rgba(255, 100, 0, 0.8)";
        ctx.fillText(`üî• KILLSTREAK x${killStreak}`, canvas.width / 2, 80);
        
        // Efecto de brillo
        ctx.strokeStyle = "rgba(255, 150, 0, 0.6)";
        ctx.lineWidth = 2;
        ctx.strokeText(`üî• KILLSTREAK x${killStreak}`, canvas.width / 2, 80);
    }
    
    // Mostrar estado del dash
    ctx.fillStyle = isDashing ? "rgba(0, 255, 255, 0.9)" : "rgba(100, 100, 100, 0.7)";
    ctx.font = "bold 14px Arial";
    ctx.textAlign = "left";
    const dashText = dashCooldown > 0 ? `DASH: ${(dashCooldown / DASH_COOLDOWN * 100).toFixed(0)}%` : "DASH: LISTO";
    ctx.fillText(dashText, 10, canvas.height - 30);
    
    
    // Mostrar pantalla de eliminaci√≥n
    if (isEliminated) {
        const timeElapsed = Date.now() - eliminationTime;
        const timeRemaining = Math.max(0, 4000 - timeElapsed);
        const secondsRemaining = Math.ceil(timeRemaining / 1000);
        
        // Fondo oscuro
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Texto principal
        ctx.fillStyle = "#ff0000";
        ctx.font = "bold 60px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("¬°HAS SIDO ELIMINADO!", canvas.width / 2, canvas.height / 2 - 60);
        
        // Nombre del atacante
        ctx.fillStyle = "#ffff00";
        ctx.font = "bold 30px Arial";
        ctx.fillText(`Eliminado por: ${eliminatedByName}`, canvas.width / 2, canvas.height / 2 + 20);
        
        // Cuenta regresiva
        ctx.fillStyle = "#00ffff";
        ctx.font = "bold 40px Arial";
        ctx.fillText(`Respawneando en: ${secondsRemaining}s`, canvas.width / 2, canvas.height / 2 + 80);
    }
    
    // Actualizar barra de vida en el DOM
    updateHealthBar();
}

// =====================================================
// EFECTO DE DESINTEGRACI√ìN
// =====================================================
function createDisintegrationEffect(x, y, color) {
    const particleCount = 50;
    for (let i = 0; i < particleCount; i++) {
        const angle = (Math.PI * 2 / particleCount) * i + (Math.random() - 0.5) * 0.8;
        const speed = 4 + Math.random() * 8;
        const size = 4 + Math.random() * 12;
        
        disintegrationEffects.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - Math.random() * 2, // Movimiento hacia arriba
            life: 80,
            maxLife: 80,
            size: size,
            color: color,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.4,
            scaleX: 1,
            scaleY: 1
        });
    }
}

// =====================================================
// SISTEMA DE VIDA Y ENERG√çA
// =====================================================
function updateHealthBar() {
    const healthPercent = (playerHealth / 500) * 100;
    const healthBarFill = document.getElementById("healthBarFill");
    const healthText = document.getElementById("healthText");
    
    healthBarFill.style.width = healthPercent + "%";
    healthText.textContent = Math.max(0, Math.floor(playerHealth)) + "/500";
    
    // Cambiar color seg√∫n la vida
    if (healthPercent > 50) {
        healthBarFill.style.background = "linear-gradient(90deg, #00ff00, #00cc00)";
    } else if (healthPercent > 25) {
        healthBarFill.style.background = "linear-gradient(90deg, #ffff00, #ffcc00)";
    } else {
        healthBarFill.style.background = "linear-gradient(90deg, #ff0000, #cc0000)";
    }
}

function updateEnergyBar() {
    const energyPercent = (playerEnergy / MAX_ENERGY) * 100;
    const energyBarFill = document.getElementById("energyBarFill");
    const energyText = document.getElementById("energyText");
    
    energyBarFill.style.width = energyPercent + "%";
    energyText.textContent = Math.floor(playerEnergy) + "/" + MAX_ENERGY;
}

// =====================================================
// CONTADOR DE JUGADORES ONLINE
// =====================================================
function updatePlayerCount() {
    const currentCount = Object.keys(players).length;
    onlineCountSpan.textContent = currentCount;
}

// =====================================================
// CONTADOR DE KILLS
// =====================================================
function updateKillCounter() {
    killCountSpan.textContent = totalKills;
}

// =====================================================
// LOOP
// =====================================================
function loop() {
    if (gameStarted) {
        updateMovement();
        updateAttack();
        interpolate();
    }
    draw(); // Siempre dibujar (incluso cuando est√° eliminado)
    updateInventoryUI(); // Actualizar cooldown visual en inventario
    updateHealthBar(); // Actualizar barra de vida
    updateEnergyBar(); // Actualizar barra de energ√≠a
    requestAnimationFrame(loop);
}

// =====================================================
// SISTEMA DE INVENTARIO
// =====================================================
function setupInventoryListeners() {
    const slots = document.querySelectorAll(".inventory-slot");
    slots.forEach(slot => {
        slot.addEventListener("click", () => {
            const weapon = slot.getAttribute("data-weapon");
            currentWeapon = weapon;
            updateInventoryUI();
        });
    });
}

function updateInventoryUI() {
    const slots = document.querySelectorAll(".inventory-slot");
    slots.forEach(slot => {
        const weapon = slot.getAttribute("data-weapon");
        if (weapon === currentWeapon) {
            slot.classList.add("active");
        } else {
            slot.classList.remove("active");
        }
        
        // Actualizar cooldown visual SOLO para el arma de fuego
        const overlay = slot.querySelector(".cooldown-overlay");
        const text = slot.querySelector(".cooldown-text");
        
        if (overlay) {
            // Solo mostrar cooldown para fireball
            if (weapon === "fireball") {
                const weaponData = weapons[weapon];
                const cooldownPercent = Math.max(0, (weaponCooldowns[weapon] / weaponData.cooldown) * 100);
                overlay.style.height = cooldownPercent + "%";
            } else {
                overlay.style.height = "0%";
            }
        }
        
        if (text) {
            // Solo mostrar texto de cooldown para fireball
            if (weapon === "fireball" && weaponCooldowns[weapon] > 0) {
                const cooldownSeconds = (weaponCooldowns[weapon] / 60).toFixed(1);
                text.textContent = cooldownSeconds;
            } else {
                text.textContent = "";
            }
        }
    });
}

// =====================================================
// SISTEMA DE CHAT
// =====================================================
function sendChatMessage() {
    if (chatInputField.value.trim() && gameStarted) {
        const msg = chatInputField.value.trim();
        
        // Enviar mensaje a Firebase en la ruta /messages
        const msgId = "msg_" + Date.now() + "_" + Math.floor(Math.random() * 1000000);
        set(ref(db, "messages/" + msgId), {
            username: myUsername,
            message: msg,
            color: myColor,
            timestamp: Date.now()
        }).catch(err => console.error("Error al enviar mensaje:", err));
        
        chatInputField.value = "";
        
        // Cerrar chat
        chatOpen = false;
        chatInput.classList.add("hidden");
        chatMessagesDiv.style.overflow = "hidden";
        chatMessagesDiv.classList.remove("chatOpen");
    }
}

chatInputField.addEventListener("keypress", (e) => {
    if (e.key === "Enter") {
        e.preventDefault();
        sendChatMessage();
    }
});

chatSendBtn.addEventListener("click", sendChatMessage);

function listenToChat() {
    onValue(ref(db, "messages"), snapshot => {
        const messages = snapshot.val() || {};
        const msgArray = Object.entries(messages).map(([key, val]) => ({key, ...val}))
            .sort((a, b) => a.timestamp - b.timestamp);
        
        // Limpiar mensajes antiguos (mantener solo los √∫ltimos 50)
        if (msgArray.length > 50) {
            const toDelete = msgArray.slice(0, msgArray.length - 50);
            toDelete.forEach(msg => {
                remove(ref(db, "messages/" + msg.key)).catch(err => console.error("Error al eliminar mensaje:", err));
            });
        }
        
        // Detectar cuando YO elimino a alguien (mensaje del SISTEMA con mi nombre)
        msgArray.forEach(msg => {
            if (msg.username === "‚öîÔ∏è SISTEMA" && msg.message.includes("ha eliminado a") && msg.message.startsWith(myUsername)) {
                // Verificar si ya contamos este kill
                if (!msg.killCounted) {
                    totalKills++;
                    killStreak++;
                    lastKillTime = Date.now();
                    updateKillCounter();
                    
                    // Marcar como contado
                    set(ref(db, "messages/" + msg.key + "/killCounted"), true).catch(err => console.error("Error al marcar kill contado:", err));
                }
            }
        });
        
        // Mostrar √∫ltimos 20 mensajes
        chatMessagesDiv.innerHTML = msgArray.slice(-20).map(m => 
            `<div class="chatMsg"><span class="username" style="color:${m.color}">${m.username}:</span> ${m.message}</div>`
        ).join("");
        
        // Mantener el overflow y estilos sincronizados con el estado del chat
        if (chatOpen) {
            chatMessagesDiv.style.overflow = "auto";
            chatMessagesDiv.classList.add("chatOpen");
        } else {
            chatMessagesDiv.style.overflow = "hidden";
            chatMessagesDiv.classList.remove("chatOpen");
        }
        
        chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
    });
}

// =====================================================
// BORRAR PLAYER AL SALIR
// =====================================================
window.addEventListener("beforeunload", () => {
    if (myId) {
        remove(ref(db, "players/" + myId));
    }
    // Limpiar escudo para evitar bugs de inmortalidad infinita
    deactivateShield();
});

</script>


</body>
</html>
